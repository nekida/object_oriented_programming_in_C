# Полиморфизм (виртуальные функции) / Polymorphism
Тут все несколько сложнее. Реализованный пример почти не опирается на предыдущие. У нас есть класс antenna и два подкласса parabolic_locator (локатор с параболической антенной) и horn_radar (радар с рупорной антенной) (названия данных объектов приведены только для большего различия и мало отражают физику и принцип работы). Подклассы наследуют от класса antenna параметр рабочей частоты (F), но и имеют свои отличительные особенности (площадь, другие значение аттенюации и фазы, разное количество излучателей и т.д.). Получение данных о количестве площади, например, зависит от физических параметров объекта: для parabolic_locator это будет pi * (R ^ 2), а для horn_radar - ширина * высота. То есть, на уровне класса antenna метод получения площади антенны одинаков для всех подклассов, но реализация для каждого конечного подкласса отличается от другой реализации другого подкласса. Другими словами, вызывая одну и ту же функцию возврата значения площади из суперкласса, должен происходить вызов уникальной для каждого подкласса функции. Для этого в класс antenna вводится постоянный указатель на структуру, полем (или полями, если функций будет несколько) является указатель на эту уникальную для каждого подкласса функцию:


`struct antenna_vtbl const *vptr;`

`struct antenna_vtbl {`
	
	uint32_t (*square)(antenna const * const me); //получить площадь антенны	
  
`};`

Реализация виртуальной функции:

Получить количество излучателей

`static inline uint32_t antenna_get_square (antenna const * const me)`

`{`

	return (*me->vptr->square)(me);  
    
`}`

Введем еще одну функцию, работающаю с коллекциями класса antenna и возвращающую объект подкласса с самой большой площадью.

Прототипы функции, вызывающий общую функцию:

`antenna const *get_antenna_with_max_square (antenna const *antennas[], uint32_t n_antennas);`

Применение виртуальных функций приводит к использованию позднего связывания или динамической привязки. Это когда экземпляр вызываемой функции определяется не в процессе компиляции и линковки, а при выполнении программы.

Практически все компиляторы C++ реализуют позднее связывание с помощью одной виртуальной таблицы (vtbl) для каждого класса и виртуального указателя (vptr) для каждого объекта. Этот метод можно применить и к C. Виртуальная таблица — это таблица указателей функций, соответствующих виртуальным функциям, представленным классом. В C виртуальная таблица может быть эмулирована структурой указателей на функции. Виртуальный указатель (vptr) — это указатель на виртуальную таблицу класса. Этот указатель должен присутствовать в каждом экземпляре (объекте) класса, поэтому он должен входить в структуру атрибутов класса.
