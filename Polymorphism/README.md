# Полиморфизм (виртуальные функции) / Polymorphism
Тут все несколько сложнее. Реализованный пример почти не опирается на предыдущие. У нас есть класс antenna и два подкласса parabolic_locator (локатор с параболической антенной) и horn_radar (радар с рупорной антенной) (названия данных объектов приведены только для большего различия и мало отражают физику и принцип работы). Подклассы наследуют от класса antenna параметр рабочей частоты (F), но и имеют свои отличительные особенности (площадь, другие значение аттенюации и фазы, разное количество излучателей и т.д.). Получение данных о количестве площади, например, зависит от физических параметров объекта: для parabolic_locator это будет pi * (R ^ 2), а для horn_radar - ширина * высота. То есть, на уровне класса antenna метод получения площади антенны одинаков для всех подклассов, но реализация для каждого конечного подкласса отличается от другой реализации другого подкласса. Другими словами, вызывая одну и ту же функцию возврата значения площади из суперкласса, должен происходить вызов уникальной для каждого подкласса функции. Для этого в класс antenna вводится постоянный указатель на структуру, полем (или полями, если функций будет несколько) является указатель на эту уникальную для каждого подкласса функцию:


`struct antenna_vtbl const *vptr;`

`struct antenna_vtbl {`
	
	uint32_t (*square)(antenna const * const me); //получить площадь антенны	
  
`};`

Реализация виртуальной функции:

Получить площадь антенны:

`static inline uint32_t antenna_get_square (antenna const * const me)`

`{`

	return (*me->vptr->square)(me);  
    
`}`

Введем еще одну функцию, работающаю с коллекциями класса antenna и возвращающую объект подкласса с самой большой площадью.

Прототипы функции, вызывающий общую функцию:

`antenna const *get_antenna_with_max_square (antenna const *antennas[], uint32_t n_antennas);`

Применение виртуальных функций приводит к использованию позднего связывания или динамической привязки. Это когда экземпляр вызываемой функции определяется не в процессе компиляции и линковки, а при выполнении программы.

В главном классе antenna создаем виртуальную таблицу с указателем на функцию-заглушку. Указател же, в каждом подклассе будет переназначаться на свою функцию.

Вызов в конструкторе:

`static struct antenna_vtbl const vtbl = {`

	`&antenna_get_square_`
	
`};`

Реализация заглушки в родительском классе:

`static uint32_t antenna_get_square_ (antenna const * const me)`

`{`

   `assert(0);` 
   
    `return 0U;` 
    
`}`

Переназначение в конструкторе подкласса horn_radar:

`static struct antenna_vtbl const vtbl = {`

	`&horn_radar_get_square_`
	
`};`

Реализация уникальной для подкласса horn_radar функции расчета площади:

`static uint32_t horn_radar_get_square_ (antenna const * const me)`

`{`

    `horn_radar const * const me_ = (horn_radar const *)me;`
    
    `return (me_->width * me_->height);`
    
`}`

В первой строчке функции происходит явное понижающее преобразование, позволяющее использовать функцию с родительским классом, но которую в самом классе не описывали.

Переназначение в конструкторе подкласса parabolic_locator:

`static struct antenna_vtbl const vtbl = {`

	`&parabolic_locator_get_square_`
	
`};`

Реализация уникальной для подкласса parabolic_locator функции расчета площади:

`static uint32_t parabolic_locator_get_square_ (antenna const * const me)`

`{`

    `parabolic_locator const * const me_ = (parabolic_locator const *)me;`
    
    `return (uint32_t)((double)me_->radius * 3.14 * 3.14);`
    
`}`
