# Инкапсуляция / Encapsulation
Файлы с именем encapsulation_\*.\*

В заголовочном файле encapsulation_antenna.h объявляем структуру antenna, которая будет выступать в качестве класса. Антенна характеризуется параметрами фаза (phase) и аттенюация (att). Прототипы функций-методов указаны ниже: antenna_constructor() - конструктор класса с инициализацией начальных параметров антенны, antenna_change() - функция изменения параметров антенны, antenna_get_ph() / antenna_get_att() - функции для чтения текущих параметров антенны.

Каждая функция получает первым параметром постоянный указатель (* const) на структуру, к которой происходит обращение в теле функции. 

В функции main() объявляются два объекта класса антенна, происходит вызов конструкторов с передачей параметров для каждого объекта, после чего иницилиализированные данные выводятся на экран, меняются через функцию и снова выводятся на экран.

# Наследование / Inheritance
Файлы с именем inheritance_\*.\*

Для создания своего рода наследования, в заголовночм файле inheritance_radar.h подключаем заголовочный файл encapsulation_antenna.h. Помещаем в структуру нового класса структуру базового суперкласса. Появится класс с названием radar, наследуемый данные от суперкласса antenna. Помимо наследуемых, объекты класса radar имеют параметры напряжение (voltage) и частота (frequency). Контсруктор нового класса, помимо данных для класса radar, должен содержать данные и для инициализации суперкласса antenna.

В функции main() объявляем два объекта класса radar и вызываем конструктор с передачей параметров и для суперкласса и для наследника. Выводим на печать, изменяем, используя методы суперкласса. Обратиться к полю суперкласса в структуре класса-наследника можно двумя способами: взятие адреса и приведение к типу указателя на стуктуру суперкласса (antenna *)&r1 и взятие адреса у поля суперкласса &r2.super. Выводим на печать измененные данные суперкласса.

# Полиморфизм (виртуальные функции) / Polymorphism
Файлы с именем polymorphism_\*.\*

Тут все несколько сложнее. Допустим, что класс antenna включает множество подклассов, помимо класса radar. Назовем один из других классов locator. Оба класса наследуют параметры суперкласса antenna, но и имеют свои отличительные особенности (другой диапазон рабочих частот, разное количество излучателей и т.д.). Получение данных о количестве излучателей, например, зависит от физических параметров объекта. То есть, на уровне класса antenna метод получения количества излучателей одинаков для всех подклассов, но реализация для каждого конечного подкласса отличается от другой реализации другого подкласса. Другими словами, вызывая одну и ту же функцию из суперкласса, должен происходить вызов уникальной для каждого подкласса функции. Для этого в класс antenna вводится постоянный указатель на структуру, содержащую указатели на эти уникальные функции:

`struct antenna_vtbl const *vptr;`

`struct antenna_vtbl {`

	  	uint32_t (*number_of_emitters)(antenna const * const me); //получить количество излучателей
  
	  	void (*change_range)(antenna const * const me); //изменить диапазон работы
  
`};`

Реализация виртуальных функций:

`static inline uint32_t antenna_get_number_of_emitters(antenna const * const me)`

`{`

		return (*me->vptr->area)(me);  
    
`}`
 
`static inline void antenna_change_range(antenna const * const me)` 

`{`

		(*me->vptr->draw)(me);
    
`}`

Прототипы функций, вызывающие общие функции:

`antenna const *get_antenna_with_max_emitters (antenna const *antennas[], uint32_t n_antennas);`

`void change_range_all_antennas (antenna const *antennas[], uint32_t n_antennas);`

Применение виртуальных функций приводит к использованию позднего связывания или динамической привязки. Это когда экземпляр вызываемой функции определяется не в процессе компиляции и линковки, а при выполнении программы.

Практически все компиляторы C++ реализуют позднее связывание с помощью одной виртуальной таблицы (vtbl) для каждого класса и виртуального указателя (vptr) для каждого объекта. Этот метод можно применить и к C. Виртуальная таблица — это таблица указателей функций, соответствующих виртуальным функциям, представленным классом. В C виртуальная таблица может быть эмулирована структурой указателей на функции. Виртуальный указатель (vptr) — это указатель на виртуальную таблицу класса. Этот указатель должен присутствовать в каждом экземпляре (объекте) класса, поэтому он должен входить в структуру атрибутов класса.

[Почитать больше теории](https://0x55.wordpress.com/2020/11/12/%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d0%b5%d0%bc-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%bd%d0%be-%d0%be%d1%80%d0%b8%d0%b5%d0%bd%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d0%be/)
